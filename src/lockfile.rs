use anyhow::Context;
use colorz::Colorize;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

// Constants
const LOCK_FILE_PATH: &str = "~/.config/snow/snow.lock";

#[derive(Serialize, Deserialize, Debug)]
pub struct Packages {
    packages: Vec<Package>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Package {
    pub name: String,
    pub origin: String,
    pub symlink: String,
}

impl Package {
    pub fn new(name: &str, origin: &str, symlink: &str) -> Self {
        Package {
            name: name.to_string(),
            origin: origin.to_string(),
            symlink: symlink.to_string(),
        }
    }
}

impl Packages {
    pub fn new() -> Self {
        Packages {
            packages: Vec::new(),
        }
    }

    pub fn add_package(&mut self, name: &str, origin: &str, symlink: &str) {
        for package in &self.packages {
            if package.name == name {
                return;
            }
        }
        self.packages.push(Package::new(name, origin, symlink));
    }

    pub fn remove_package(&mut self, name: &str) {
        self.packages.retain(|p| p.name != name);
    }

    pub fn find_package(&self, name: &str) -> Option<&Package> {
        self.packages.iter().find(|p| p.name == name)
    }

    pub fn get_packages(&mut self) -> Vec<Package> {
        self.packages.clone()
    }

    pub fn list_symlinks(&self) {
        let longest_link_len = self
            .packages
            .iter()
            .map(|p| p.symlink.len())
            .max()
            .unwrap_or(0);
        for (index, package) in self.packages.iter().enumerate() {
            println!(
                "{} {:<width$} {} {}",
                index + 1,
                package.symlink.green(),
                "=>".cyan(),
                package.origin,
                width = longest_link_len
            );
        }
    }
}

/// Read the lock file
///
/// If the lock file does not exist, this function will create a new empty Packages object,
/// write a new lock file, and return this new Packages object.
///
/// If the lock file exists, this function will read the file content, try to parse it into a Packages object,
/// and return this object. If the parsing fails, it will return an error.
pub fn read_snowlock() -> anyhow::Result<Packages> {
    let lock_file_path = expand_path(LOCK_FILE_PATH)?;

    // If the lock file does not exist, create a new Packages object and write a new lock file
    if fs::metadata(&lock_file_path).is_err() {
        let packages = Packages::new();
        write_snowlock(&packages)?;
        return Ok(packages);
    }

    let content = fs::read_to_string(&lock_file_path)?;

    // Try to parse the content as a Packages object
    let packages: Packages = toml::from_str(&content)
        .map_err(|err| anyhow::anyhow!("Failed to parse lock file: {}", err))?;

    Ok(packages)
}

/// Write a Packages object to the lock file
///
/// This function first checks and creates the necessary directories, then converts the Packages object to TOML format,
/// adds a comment stating that this file is automatically generated and should not be manually changed, and then writes the final content to the lock file.
///
/// If the Packages object cannot be converted to TOML format, this function will return an error.
pub fn write_snowlock(packages: &Packages) -> anyhow::Result<()> {
    let lock_file_path = expand_path(LOCK_FILE_PATH)?;

    // 检查并创建目录
    if let Some(parent_dir) = lock_file_path.parent() {
        fs::create_dir_all(parent_dir)?;
    }

    // 尝试将 Packages 对象转换为 TOML 格式
    let content = toml::to_string_pretty(packages)
        .map_err(|err| anyhow::anyhow!("Failed to convert packages to TOML: {}", err))?;

    // 添加一个注释说明这个文件是自动生成的，不应手动更改
    let name = env!("CARGO_PKG_NAME");
    let version = env!("CARGO_PKG_VERSION");
    let comment = format!(
        "# This file is automatically @generated by {} {} and should not be changed by hand.",
        name, version
    );

    // 将最终的内容写入锁文件
    let final_content = format!("{}\n\n{}", comment, content);
    fs::write(lock_file_path, final_content)?;
    Ok(())
}

/// Clear all packages in the lock file
///
/// This function achieves this by creating a new empty Packages object and writing it to the lock file.
#[allow(dead_code)]
pub fn clear_packages() -> anyhow::Result<()> {
    let packages = Packages::new();

    // Write the new Packages object to the lock file to clear all packages
    write_snowlock(&packages)?;

    Ok(())
}

/// Delete the lock file
///
/// This function first gets the path of the lock file, then checks if the file exists, if it does, it deletes it.
pub fn delete_lockfile() -> anyhow::Result<()> {
    let lock_file_path = expand_path(LOCK_FILE_PATH)?;
    if lock_file_path.exists() {
        fs::remove_file(lock_file_path)?;
    }

    Ok(())
}

/// Expand the given path, replacing "~" with the user's home directory
///
/// This function first gets the user's home directory, then uses the shellexpand::tilde function to expand the path,
/// and finally converts the expanded path into a PathBuf object and returns it.
pub fn expand_path(path: &str) -> anyhow::Result<PathBuf> {
    let homedir = dirs::home_dir().context("Failed to determine home directory")?;
    let homedir_str = homedir.to_str().context("Invalid home directory")?;

    // shellexpand::tilde function expands the path
    let expanded_path = shellexpand::tilde(path).replace('~', homedir_str);

    // Convert the expanded path to a PathBuf object and return it
    Ok(PathBuf::from(expanded_path))
}
